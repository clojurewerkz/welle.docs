---
title: "Getting Started"
layout: article
---

## About this guide

This guide combines an overview of Welle with a quick tutorial that helps you to get started with it.
It should take about 10 minutes to read and study the provided code examples. This guide covers:

 * Features of Welle
 * Clojure and Riak version requirements
 * How to add Welle dependency to your project
 * Basic operations (creating buckets, storing and fetching objects, index queries, using map/reduce)
 * Overview of how Welle automatic serialization works

This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/3.0/">Creative Commons Attribution 3.0 Unported License</a> (including images & stylesheets). The source is available [on Github](https://github.com/clojurewerkz/welle.docs).


## What version of Welle does this guide cover?

This guide covers Welle 1.0.0-rc1, the most recent pre-release version. Welle is a young project but most of the public API
is fleshed out and will not change before the 1.0 release.


## Welle Overview

Welle is an idiomatic Clojure client for Riak. It is simple and easy to use, strives to support
every Riak 1.0+ feature, has next to no performance overhead compared to the official Java client and is well maintained.


### What Welle is not

Welle is not a replacement for the Riak Java client, instead, Welle is symbiotic with it. Welle does not try to offer
object/document mapping functionality or introduce abstractions on top of what Clojure and Riak have. With Welle, you work with native
Clojure and Java data structures like maps, vectors, strings, dates and so on. This approach has pros and cons but (we believe) closely follows
Clojure's philosophy of reducing incidental complexity. It also fits key/value data model of Riak very well.


## Supported Clojure versions

Welle is built from the ground up for Clojure 1.3 and later.


## Supported Riak versions

Welle currently uses Riak Java driver 1.0.x under the hood and thus supports Riak 1.0 and later versions. Please note that some
features may be specific to Riak 1.1 and later versions.


## Adding Welle Dependency To Your Project

### With Leiningen

    [com.novemberain/welle "1.0.0-rc1"]

### With Maven

    <dependency>
      <groupId>com.novemberain</groupId>
      <artifactId>welle</artifactId>
      <version>1.0.0-rc1</version>
    </dependency>

It is recommended to stay up-to-date with new versions. New releases and important changes are announced [@ClojureWerkz](http://twitter.com/ClojureWerkz).


## Connecting to Riak

Riak and Welle support two transports: HTTP and Protocol Buffers. They vary in performance characteristics and supported features. For the
purpose of this guide we will concentrate on the HTTP transport. This is what most applications use and it delivers pretty good performance
most applications will be satisfied with.

### Using HTTP transport

`clojurewerkz.welle.core/connect!` function connects to Riak using HTTP transport and sets up the default client. You can invoke it in
three ways:

{% gist 8e434397887f5c88be23 %}

It is very common to use the 0-arity (first example) in development and the 1-arity (second example) for QA and production environments.
Most of the time, relying on client id to be generated by Welle is sufficient. You can learn more about [client ids and how they are used
by Riak](http://wiki.basho.com/Vector-Clocks.html) for conflict detection and resolution in the Riak documentation.



## Creating buckets

Riak stores data in [buckets](http://wiki.basho.com/Riak-Glossary.html#Bucket) (similar to tables in relational databases and collections in MongoDB).
So, before storing data, it is a good idea to prepare a bucket. You use `clojurewerkz.welle.buckets/update` function to do it. In the simplest case,
you only pass it the name of the bucket:

{% gist fa06adda8ea6491d1516 %}

Riak buckets have properties. In the example above, we rely on all defaults. In many cases, you will want to tweak bucket properties.
To do so, pass additional arguments to `clojurewerkz.welle.buckets/update`, like so:

{% gist 94af48ceb14fea0e77f7 %}

in the example above we instruct Riak to replicate all objects stored in the bucket "accounts" to 5 nodes (because accounts are
valuable information we absolutely don't want to lose).


## Storing values

Besides showing off impressive benchmarks and striving to handle [Web Scale](http://www.youtube.com/watch?v=b2F-DItXtZs), the primary purpose of data stores like Riak
is to store data.
Riak has several components to it but it is a key/value store at heart. You interact with it using functions in the `clojurewerkz.welle.kv` namespace. For example,
`clojurewerkz.welle.kv/store` function stores objects in Riak. It takes a bucket name, a key and a value:

{% gist 8336e8887bb37e258621 %}

In the example above we store some data as bytes: Riak is content agnostic and will happily store whatever you throw at it. However, most applications
work with data more structured than raw bytes, for example, as JSON documents or text in the CSV format. To make developer experience a bit nicer,
Riak will store content type of the stored value and Welle will automatically serialize stored value if content type is one of

 * JSON
 * JSON in UTF-8
 * Clojure data (that can be read by the Clojure reader)
 * Text
 * Text in UTF-8

Content type is passed as one of the optional arguments to the same function, `clojurewerkz.welle.kv/store`:

{% gist 62b9de5d322690b7efbf %}

Often you will want to use constants provided by the Riak Java client (that Welle uses underneath):

{% gist 4d67f00b740e1fc74724 %}

However, Riak Java client constants do not include Clojure data content type. To use it, pass "application/clojure" as the content type:

{% gist 65b3f1dcdcf7ee026cf8 %}

Serialized values will be deserialized automatically by Welle when you fetch them, as you will see later in this guide.



## Fetching values

To fetch a stored value, use `clojurewerkz.welle.kv/fetch` function. In the simplest case it takes a bucket name and a key:

{% gist 9978c3d0ad6c4d668885 %}

It returns *a list of values* because in an eventually consistent system like Riak it is sometimes possible that multiple
versions of an object will be stored in a cluster. They are called [siblings](http://wiki.basho.com/Vector-Clocks.html#Siblings). We won't
get into siblings and conflicts resolution in this guide, just be aware of this possibility and that `clojurewerkz.welle.kv/fetch` returns
a list.

Granted, most of the time (in systems that are light on writes, almost always) the list will only contain one value. Fortunately,
Clojure has us covered here: it is possible use positional destructuring to get the value without additional calls to `clojure.core/first`:

{% gist af3dd517ea8f094a1a47 %}

So if you are sure that there will be no conflicts, this practice is encouraged.

So far we haven't passed any arguments to `clojurewerkz.welle.kv/fetch`. In case you need to do it, it is very similar to how you do
it when storing data:

{% gist 947cda5651405cffbda6 %}

For those familiar with the Riak Java client, quorum values can be passed as `com.basho.riak.client.cap.Quora` and `com.basho.riak.client.cap.Quorum`
instances, too:

{% gist 41157189e87b56d46aa8 %}


## Using secondary indexes

Fetching data by key may get you quite far if you are smart about choose keys but often it is more convenient to use secondary indexes to
query your data. Secondary indexes (often referred to as 2i) have two sides to them:

 * Indexing data
 * Querying

With Riak, you specify indexes and index values when storing values using the `:indexes` option:

{% gist 18f1ab3abea1a942e9e0 %}

Each value may have its own set of indexes. There is no predefined set of indexes, like with some other data stores (for example, PostgreSQL).
If index values are specified for an object, Riak will index the value and distribute information about the new index entry in the cluster.
Please note that string indexes need to be passed as sets (and may contain multiple values).



## Secondary index queries

Once you have some objects stored and indexed, lets take a look how to perform 2i queries with Welle. `clojurewerkz.welle.kv` namespace
provides a function to do it, `index-query`. It is used similarly to `clojurewerkz.welle.kv/fetch`:

{% gist 43b4a2b151994612d4cf %}

You pass it the name of the index to use and a value. Welle will return you a list of keys that you can then fetch, combine with
a list of keys returned by another index query or use with map/reduce.

Riak also supports range queries. In the example used throughout this guide we index a user's age. To get a list of keys of objects
with ages between 25 and 30, pass a pair (typically as a vector, so `[25 30]`) for index value:

{% gist 5b9a9da82b75b7c5a4bf %}


## Deleting values

To delete an object, use `clojurewerkz.welle.kv/delete` function. In the simplest case it takes a bucket name and a key,
just like `clojurewerkz.welle.kv/fetch`:

{% gist 0eb8f9519a930b529a99 %}



## Using Map/Reduce

TBD


## What to read next

The documentation is organized as a number of guides, covering all kinds of topics.

We recommend that you read the following guides first, if possible, in this order:

 * [Connecting to Riak](/articles/connecting.html)
 * [Working with buckets](/articles/buckets.html)
 * [Key/Value Operations](/articles/kv.html)
 * [Secondary indexes](/articles/2i.html)
 * [Links and link walking](/articles/links.html)
 * [Map/Reduce](/articles/mapreduce.html)
 * [Integration with 3rd party libraries](/articles/integration.html)



## Tell Us What You Think!

Please take a moment to tell us what you think about this guide on Twitter or the [Welle mailing list](https://groups.google.com/forum/#!forum/clojure-riak)

Let us know what was unclear or what has not been covered. Maybe you do not like the guide style or grammar or discover spelling mistakes. Reader feedback is key to making the documentation better.
